#ifndef COMPILER_H
#define COMPILER_H

#include <iostream>
#include <cctype>
#include <exception>
#include <fstream>
#include <limits>
#include <map>
#include <sstream>
#include <string>
#include <typeinfo>
#include <vector>

using namespace std;

#define REGISTER_SIZE 256
#define MEMORY_SIZE 8388608

// Define enumeration type to encapsulate the character classes
enum CharacterClass { DIGIT, ILLEGAL, LETTER, PUNCTUATION};

// Define enumeration type to encapsulate the token types
enum TokenType { IDENTIFIER, NONE, NUMBER, OPERATOR, RESERVE, STRING, UNKNOWN };

// Define enumeration type to encapsulate data types for type checker
enum DataType { INVALID, STRINGT, BOOL, INTEGER, FLOAT };

// Define data structure for a basic token generated by the scanner
struct TokenFrame
{
	TokenType tokenType;
	string name;
	bool isGlobal;
};

// Base Token class
// Reserve Words and Operators will use this class
class Token
{
	public:
		// Constructors
		// Initialize Constructor
		Token( const TokenType& newTokenType, const string& newName, const bool& newGlobal ) : m_tokenType( newTokenType ), m_name( newName ), m_isGlobal( newGlobal )
		{
		}
		
		// Destructor (virtual to cover for polymorphism)
		virtual ~Token( void )
		{
		}
		
		// Accessor Methods
		TokenType getTokenType( void ) const
		{
			return m_tokenType;
		}
		
		string getName( void ) const
		{
			return m_name;
		}
		
		bool getGlobal( void ) const
		{
			return m_isGlobal;
		}
		
	protected:
		TokenType m_tokenType;
		string m_name;
		bool m_isGlobal;
};

// Variable Token class (inherits Token)
class Variable : public Token
{
	public:
		// Constructors
		// Initialize Constructor
		Variable( const TokenType& newTokenType, const string& newName, const DataType& newDataType, const bool& newGlobal, const int& newAddress, const bool& newParameter ) : Token( newTokenType, newName, newGlobal ), m_dataType( newDataType ), m_address( newAddress ), m_isParameter( newParameter )
		{
		}
		
		// Destructor (virtual to cover polymorphism)
		virtual ~Variable( void )
		{
		}
		
		// Accessor Methods
		DataType getDataType( void ) const
		{
			return m_dataType;
		}
		
		int getAddress( void ) const
		{
			return m_address;
		}
		
		bool getParameter( void ) const
		{
			return m_isParameter;
		}
		
	protected:
		DataType m_dataType;
		int m_address;
		bool m_isParameter;
};

// Array Token class (inherits Variable)
class Array : public Variable
{
	public:
		// Constructors
		// Initialize Constructor
		Array( const TokenType& newTokenType, const string& newName, const DataType& newDataType, const int& newArraySize, const bool& newGlobal, const int& newAddress, const bool& newParameter ) : Variable( newTokenType, newName, newDataType, newGlobal, newAddress, newParameter ), m_arraySize( newArraySize )
		{
		}
		
		// Destructor (virtual to cover polymorphism)
		virtual ~Array( void )
		{
		}
		
		// Accessor Methods
		int getArraySize( void ) const
		{
			return m_arraySize;
		}
		
	protected:
		int m_arraySize;
};

// Procedure Token class (inherits Token)
class Procedure : public Token
{
	public:
		// Constructors
		// Initialize Constructor
		Procedure( const TokenType& newTokenType, const string& newName, const bool& newGlobal ) : Token( newTokenType, newName, newGlobal ), m_localAddress( 0 ), m_parameterAddress( 0 ), m_returnAddress( 0 )
		{
			m_parameterList.clear();
			m_directionList.clear();
		}
		
		// Destructor (virtual to cover polymorphism)
		virtual ~Procedure( void )
		{
			for( int i = 0; i < m_parameterList.size(); i++ )
			{
				delete m_parameterList[i];
			}
		}
		
		// Accessor Methods
		// Returns the number of parameters in the parameter list
		int getParameterListSize( void ) const
		{
			return m_parameterList.size();
		}
		
		// Returns the type of the specified parameter. The first one is numbered at 0.
		DataType getParameterType( const int& n ) const
		{
			if( n >= 0 && n < m_parameterList.size() )
			{
				return m_parameterList[n]->getDataType();
			}
			else
			{
				return INVALID;
			}
		}
		
		// Returns the symbol table entry for the specified parameter
		Variable* getParameter( const int& n ) const
		{
			if( n >= 0 && n < m_parameterList.size() )
			{
				return m_parameterList[n];
			}
			else
			{
				return NULL;
			}
		}
		
		// Returns the direction of the specified parameter. The first one is numbered at 0.
		bool getDirection( const int& n ) const
		{
			if( n >= 0 && n < m_directionList.size() )
			{
				return m_directionList[n];
			}
			else
			{
				return true;
			}
		}
		
		// Returns the next available parameter address
		int getParameterAddress( void ) const
		{
			return m_parameterAddress;
		}
		
		// Returns the next available local scope address
		int getLocalAddress( void ) const
		{
			return m_localAddress;
		}
		
		// Returns the next available return address
		int getReturnAddress( void ) const
		{
			return m_returnAddress;
		}
		
		// Mutator Methods
		// Adds the specified variable to the parameter list
		void addParameter( Variable* newParameter )
		{
			m_parameterList.push_back( newParameter );
		}
		
		// Adds a boolean value to the list of parameter directions
		// true = in, false = out
		void addDirection( const bool& newDirection )
		{
			m_directionList.push_back( newDirection );
		}
		
		// Increase the pointer to next available parameter address by one unit
		void advanceParameterAddress( void )
		{
			m_parameterAddress++;
		}
		
		// Increase the pointer to next available local address by one unit
		void advanceLocalAddress( void )
		{
			m_localAddress++;
		}
		
		// Increase the pointer to next available return address
		void advanceReturnAddress( void )
		{
			m_returnAddress++;
		}
		
	protected:
		vector<Variable*> m_parameterList;
		vector<bool> m_directionList;
		int m_parameterAddress; // Keeps track of the next available address for procedure parameters
		int m_localAddress; // Keeps track of the next available address for local variables
		int m_returnAddress; // Keeps track of the next available return address for the procedure
};

// Used for throwing exceptions for unexpected EOF
class EOFException : public exception
{
	public:
		// Returns a string containing a description of the EOF error message
		virtual const char* what() const throw ()
		{
			return "Unexpected end of file";
		}
};

// Used to throw exceptions due to syntax error
class CompileErrorException : public exception
{
	public:
		// Constructor for the CompileErrorException class.
		// An object of this class must be instanciated with the compiler's message
		CompileErrorException( string complaint ) : exception(), message( complaint ), printed( false )
		{
		}
		
		virtual ~CompileErrorException() throw()
		{
		}
		
		// Returns the string containing the compiler's error message
		virtual const char* what() throw ()
		{
			if( !printed )
			{
				printed = true;
				return message.c_str();
			}
		}
	
	private:
		string message;
		bool printed; // tells whether the message has already been displayed
};

typedef map<string, Token*> SymbolTable;

// To keep track of the scanner's current line number
extern int lineNumber;

// To keep track of the number of warnings found
extern int warningCount;

// To keep track of the number of errors found
extern int errorCount;

// Stores the symbol table for the global scope
extern SymbolTable globalSymbolTable;

// Stores the chain of local symbol tables
// The 0th element is for the main program block, so this vector will always have at least one element
extern vector<SymbolTable> localSymbolTable;

// To keep track of the current scope of the parse
// Scope -1 is global
// Scope 0 is the main program block
// This value increases by one every time the parse enters a procedure and subsequent nested procedures.
// This value decreases by one every time the parse leaves a scope.
extern int currentScope;

// File handler for the input file to be compiled
extern ifstream inFile;

// File handler for the output file of the compiler
extern ofstream outFile;

// Location: compiler.cpp
// This function adds an entry to the symbol table with the specified token type
extern void addSymbolEntry( Token* newToken );

// Location: compiler.cpp
// This function searches the symbol table for the specified entry.
// If the entry modifies the token passed with the token's type (IDENTIFIER or RESERVE)
// It also provides the data type of the token was already used in a declaration
extern void findSymbolEntry( TokenFrame& newToken );

// Location: compiler.cpp
// Reports warnings by printing line number and message to stderr
extern void reportWarning( const string& message );

// Location: compiler.cpp
// Reports errors by printing line number and message to stderr
extern void reportError( const string& message );

// Location: scanner.cpp
// This function initializes global counters and sets up file I/O for the scanner
extern void initializeScanner( const char* inputFile );

// Location: scanner.cpp
// This function retrieves the next token from the input file ( already open by initializeScanner() ) and returns it to the calling function
extern TokenFrame getToken( void );

// Location: scanner.cpp
// This function determines the character class of the specified character
extern CharacterClass getCharacterClass( const char& ch );

// Location: parser.cpp
// This function begins parsing of the grammar/syntax with the first grammar rule
extern void readProgram( void );

#endif
