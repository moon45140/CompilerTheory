#ifndef COMPILER_H
#define COMPILER_H

#include <iostream>
#include <cctype>
#include <exception>
#include <fstream>
#include <limits>
#include <map>
#include <sstream>
#include <string>
#include <vector>

using namespace std;

// Define enumeration type to encapsulate the character classes
enum CharacterClass { DIGIT, ILLEGAL, LETTER, PUNCTUATION};

// Define enumeration type to encapsulate the token types
enum TokenType { IDENTIFIER, NONE, NUMBER, OPERATOR, RESERVE, STRING, UNKNOWN };

// Define enumeration type to encapsulate data types for type checker
enum DataType { INVALID, STRINGT, BOOL, INTEGER, FLOAT };

typedef vector<DataType> ParameterList;

// Define data structure for a basic token generated by the scanner
struct TokenFrame
{
	TokenType tokenType;
	string name;
	bool isGlobal;
};

// Base Token class
// Reserve Words and Operators will use this class
class Token
{
	public:
		// Constructors
		// Default Constructor
		Token() : m_tokenType( UNKNOWN )
		{
			m_name.clear();
			m_isGlobal = false;
		}
		
		// Initialize Constructor
		Token( const TokenType& newTokenType, const string& newName, const bool& newGlobal ) : m_tokenType( newTokenType ), m_name( newName ), m_isGlobal( newGlobal )
		{
		}
		
		// Destructor (virtual to cover for polymorphism)
		virtual ~Token()
		{
		}
		
		// Accessor Methods
		TokenType getTokenType() const
		{
			return m_tokenType;
		}
		
		string getName() const
		{
			return m_name;
		}
		
		bool getGlobal() const
		{
			return m_isGlobal;
		}
		
		// The following accessors are here because they exist in derived classes
		virtual DataType getDataType() const
		{
			return INVALID;
		}
		
		virtual int getArraySize() const
		{
			return -1;
		}
		
		virtual int getParameterListSize() const
		{
			return -1;
		}
		
		virtual DataType getParameter( const int& n ) const
		{
			return INVALID;
		}
		
		// Mutator Methods
		void setTokenType( const TokenType& newTokenType )
		{
			m_tokenType = newTokenType;
		}
		
		void setName( const string& newName )
		{
			m_name = newName;
		}
		
		void setGlobal( const bool& newGlobal )
		{
			m_isGlobal = newGlobal;
		}
		
		// The following mutators are here because they exist in derived classes
		virtual void setDataType( const DataType& newDataType )
		{
		}
		
		virtual void setArraySize( const int& newArraySize )
		{
		}
		
		virtual void addParameter( const DataType& newDataType )
		{
		}
		
	protected:
		TokenType m_tokenType;
		string m_name;
		bool m_isGlobal;
};

// Procedure Token class (inherits Token)
class Procedure : public Token
{
	public:
		// Constructors
		// Default Constructor
		Procedure() : Token()
		{
			m_parameterList.clear();
		}
		
		// Initialize Constructor
		Procedure( const TokenType& newTokenType, const string& newName, const bool& newGlobal ) : Token( newTokenType, newName, newGlobal )
		{
			m_parameterList.clear();
		}
		
		// Destructor (virtual to cover polymorphism)
		virtual ~Procedure()
		{
		}
		
		// Accessor Methods
		// Returns the number of parameters in the parameter list
		virtual int getParameterListSize() const
		{
			return m_parameterList.size();
		}
		
		// Returns the type of the specified parameter. The first one is numbered at 0.
		virtual DataType getParameter( const int& n ) const
		{
			if( n >= 0 && n < m_parameterList.size() )
			{
				return m_parameterList[n];
			}
			else
			{
				return INVALID;
			}
		}
		
		// Mutator Methods
		// Adds the specified data type to the parameter list
		virtual void addParameter( const DataType& newDataType )
		{
			m_parameterList.push_back( newDataType );
		}
		
	protected:
		ParameterList m_parameterList;
};

// Variable Token class (inherits Token)
class Variable : public Token
{
	public:
		// Constructors
		// Default Constructor
		Variable() : Token(), m_dataType( INVALID )
		{
		}
		
		// Initialize Constructor
		Variable( const TokenType& newTokenType, const string& newName, const DataType& newDataType, const bool& newGlobal ) : Token( newTokenType, newName, newGlobal ), m_dataType( newDataType )
		{
		}
		
		// Destructor (virtual to cover polymorphism)
		virtual ~Variable()
		{
		}
		
		// Accessor Methods
		virtual DataType getDataType() const
		{
			return m_dataType;
		}
		
		// The following accessors are here because they exist in derived classes
		virtual int getArraySize() const
		{
			return 0;
		}
		
		// Mutator Methods
		virtual void setDataType( const DataType& newDataType )
		{
			m_dataType = newDataType;
		}
		
		// The following mutators are here because they exist in derived classes
		virtual void setArraySize( const int& newArraySize )
		{
		}
		
	protected:
		DataType m_dataType;
};

// Array Token class (inherits Variable)
class Array : public Variable
{
	public:
		// Constructors
		// Default Constructor
		Array() : Variable(), m_arraySize( 1 )
		{
		}
		
		// Initialize Constructor
		Array( const TokenType& newTokenType, const string& newName, const DataType& newDataType, const int& newArraySize, const bool& newGlobal ) : Variable( newTokenType, newName, newDataType, newGlobal ), m_arraySize( newArraySize )
		{
		}
		
		// Destructor (virtual to cover polymorphism)
		virtual ~Array()
		{
		}
		
		// Accessor Methods
		virtual int getArraySize() const
		{
			return m_arraySize;
		}
		
		// Mutator Methods
		virtual void setArraySize( const int& newArraySize )
		{
			m_arraySize = newArraySize;
		}
		
	protected:
		int m_arraySize;
};

// Used for throwing exceptions for unexpected EOF
class EOFException : public exception
{
	public:
		// Returns a string containing a description of the EOF error message
		virtual const char* what() const throw ()
		{
			return "Unexpected end of file";
		}
};

// Used to throw exceptions due to syntax error
class CompileErrorException : public exception
{
	public:
		// Constructor for the CompileErrorException class.
		// An object of this class must be instanciated with the compiler's message
		CompileErrorException( string complaint ) : exception(), message( complaint ), printed( false )
		{
		}
		
		virtual ~CompileErrorException() throw()
		{
		}
		
		// Returns the string containing the compiler's error message
		virtual const char* what() throw ()
		{
			if( !printed )
			{
				printed = true;
				return message.c_str();
			}
		}
	
	private:
		string message;
		bool printed; // tells whether the message has already been displayed
};

typedef map<string, Token*> SymbolTable;

// To keep track of the scanner's current line number
extern int lineNumber;

// To keep track of the number of warnings found
extern int warningCount;

// To keep track of the number of errors found
extern int errorCount;

// Stores the symbol table for the global scope
extern SymbolTable globalSymbolTable;

// Stores the chain of local symbol tables
// The 0th element is for the main program block, so this vector will always have at least one element
extern vector<SymbolTable> localSymbolTable;

// To keep track of the current scope of the parse
// Scope -1 is global
// Scope 0 is the main program block
// This value increases by one every time the parse enters a procedure and subsequent nested procedures.
// This value decreases by one every time the parse leaves a scope.
extern int currentScope;

// To flag whether a declaration is global
extern bool isGlobal;

// Pointer to the symbol table entry for the current procedure being declared
extern Token* currentProcedure;

// To flag whether a call to readVariableDeclaration() is from readParameter or readDeclarations()
extern bool isParameter;

// File handler for the input file to be compiled
extern ifstream inFile;

// File handler for the output file of the compiler
// extern ofstream outFile;

// Location: compiler.cpp
// This function adds an entry to the symbol table with the specified token type
extern void addSymbolEntry( Token* newToken );

// Location: compiler.cpp
// This function searches the symbol table for the specified entry.
// If the entry modifies the token passed with the token's type (IDENTIFIER or RESERVE)
// It also provides the data type of the token was already used in a declaration
extern void findSymbolEntry( TokenFrame& newToken );

// Location: compiler.cpp
// Reports warnings by printing line number and message to stderr
extern void reportWarning( const string& message );

// Location: compiler.cpp
// Reports errors by printing line number and message to stderr
extern void reportError( const string& message );

// Location: scanner.cpp
// This function initializes global counters and sets up file I/O for the scanner
extern void initializeScanner( const char* inputFile );

// Location: scanner.cpp
// This function retrieves the next token from the input file ( already open by initializeScanner() ) and returns it to the calling function
extern TokenFrame getToken();

// Location: scanner.cpp
// This function determines the character class of the specified character
extern CharacterClass getCharacterClass( const char& ch );

// Location: parser.cpp
// This function begins parsing of the grammar/syntax with the first grammar rule
extern void readProgram();

// Location: parser.cpp
extern void readProgramHeader();

// Location: parser.cpp
extern void readProgramBody();

// Location: parser.cpp
extern void readDeclarations();

// Location: parser.cpp
extern void readProcedureDeclaration();

// Location: parser.cpp
extern void readProcedureHeader();

// Location: parser.cpp
extern void readParameterList();

// Location: parser.cpp
extern void readParameter();

// Location: parser.cpp
extern void readProcedureBody();

// Location: parser.cpp
extern void readVariableDeclaration();

// Location: parser.cpp
extern void readStatements();

// Location: parser.cpp
extern void readProcedureCall();

// Location: parser.cpp
extern void readArgumentList( Procedure* myProcedure, const int& parameterNumber, int& argumentCount );

// Location: parser.cpp
extern void readAssignment();

// Location: parser.cpp
extern void readIf();

// Location: parser.cpp
extern void readLoop();

// Location: parser.cpp
extern DataType readExpression();

// Location: parser.cpp
extern DataType readArithOp();

// Location: parser.cpp
extern DataType readRelation();

// Location: parser.cpp
extern DataType readTerm();

// Location: parser.cpp
extern DataType readFactor();

// Location: parser.cpp
extern DataType readName();

#endif